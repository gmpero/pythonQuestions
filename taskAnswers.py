1.
a_string = 'airplane'
another_string = 'airplanes'
print(len(another_string) >= len(a_string))
#True
2. 
print('100' == 100)
#False
3.
print(100 - 97 in [5,1,92,7,17,13])
#False
4.
a_number = 2
anothen_number = 17
print((a_number + anothen_number) > 19)
#False
5.
print(not False == True)
#True
6. 
print('a'.isupper() == (not False))
#False
7.
print(sorted([2,4,7,1]) == [1,2,4,7])
#True
8.
a_string = 'airplane'
another_string = 'airplanes'
print(a_string[0] != another_string[5])
#False
9.
a_string = 'airplane'
another_string = 'airplanes'
print(a_string[3:] == another_string[3:8])
#True
10.
a_list = ['hello',['what','is'],'happening','here']
#True
11.
a_dist = {'a': [1,2],'b': 'hello'}
print(len(a_dist['a']) <=2)
#True
12.
a_set = set([1,4,6,8,2,3,1,1,3,5])
a_set.update([1,3,4,1,1])
print(len(a_set) == 7)
#False
13.
letters = ['a','b','c','d']
numbers = set([1,2,3,4,5])
print(all([len(letters)== 4,
len(numbers) != 5]))
#False
14.
a_string = 'airplane'
another_string = 'airplanes'
print(any([len(a_string) == 7,
          a_string == another_string,
          (2 + 17 +2)>21]))
#False
15.
print(all(['airplane'.startswith('air'),
           'airplane'.replace('a','b') == "birplane",
           'airplane' not in ['the airplane','is in the air']]))
#False
16.
#Что выведет 
print(len([5,2,[1,2],3]))
#4
17.
# Объясните три способа Python's slicing.
# К примеру что будет напечатано?
#slice(start, stop[, step])
print('Bananas are yummy.'[1:-1:2])
#aaa r um
18.
# В чем разница между (args) (kwargs)
#Термины args и kwargs — это соглашения 
#по программированию на Python, в реальности 
#вместо них можно использовать любые именования. 
#*args представляет параметры, которые передаются 
#по позиции. А **kwargs означает параметры, 
#которые передаются по имени. 
#обозначает аргументы ключевого слова.
#Оператор * позволяет передать в функцию несколько значений, и все они будут упакованы в кортеж:
def fun(*args):
    # обращаемся к первому элементу кортежа
    print(args[0])
  
    # выводим весь кортеж
    print(args)
  
fun("Python", "C++", "Java", "C#")

#Оператор ** упаковывает аргументы, 
#переданные по имени, в словарь. 
#Имена параметров служат ключами. 
#Например, определим функцию, 
#которая просто будет выводить 
#все переданные параметры
def fun(**kwargs):
    print(kwargs)   # выводим словарь на консоль
  
fun(name="Tom", age="38", company="Google")
fun(language="Python", version="3.11")

19.
# Объясните continue, break, и pass statements do
# В Python оператор pass является пустой операцией. 
# При его выполнении ничего не происходит. 
# Это заполнитель, который используется там, 
# где синтаксис требует оператора, но вы не хотите,
# чтобы какая-либо команда или код выполнялись.

for i in range(5):
    if i == 3:
        pass
    print(i)

# Statements - инструкция как считается код
    
print('Mother of Dragons.')
print('Dracarys!')

print('Mother of Dragons.'); print('Drakarys!')

20.
# Как простым способом распечатать следуюзее построчно имя в отдельной строчке?
print(' '.join(['Alan','Maria','Paul']))

print('\n'.join(['Alan','Maria','Paul']))

21.
#сократите выражение : a < b and c > b
#a < b < c

22.
# Какие два типа объектов задаются с помощью {}
#Словарь состоит из пар ключ-значение. Он заключен в фигурные скобки {}, а значения можно назначать и получать к ним доступ в квадратных скобках [].
dic={'name':'red','age':10}
print(dic)
#Наборы представляют собой неупорядоченные наборы уникальных объектов, существует два типа наборов:
#Наборы - они изменчивы и новые элементы могут быть добавлены после определения наборов
basket = {'apple', 'orange', 'apple', 'pear', 'orange', 'banana'} 
print(basket)    

23.
# Что такоке max()? например 
print(max([1,2,3]))

24.
# как превратить строковый литерал в число ()
print(type(int("10")))

25.
# как отстортировать список в обратном порядке с помощью sorted()
list1 = [5,1,3,2]
print(sorted(list1, reverse=True))

26.
# Какие встроенные функции нужно использовать для итерации по целым числам до 100
1.
numbers = [s for s in range(100)]
iterator = iter(numbers)  # получаем итератор
print(next(iterator))  # 1
print(next(iterator))  # 2

2.
for num in range(100):
    print(num)

27.
# Какие встроенные функции нужно использовать чтобы получить справку о данной функции
#help
# Как использовать *args **kwargs
def fun(*args):
    # обращаемся к первому элементу кортежа
    print(args[0])
  
    # выводим весь кортеж
    print(args)
  
fun("Python", "C++", "Java", "C#")

def fun(**kwargs):
    print(kwargs)   # выводим словарь на консоль
  
fun(name="Tom", age="38", company="Google")
fun(language="Python", version="3.11")

# найти ошибку
1.
shopping_list = {"apples":5,"bananas":3,"pineapples":2}
#for product in shopping_list:
#   number = shopping_list[product]
#   print('We need' + numbers + ' ' + product)

for product in shopping_list:
    number = shopping_list[product]
    print('We need ' + str(number) + ' ' + product)

2.
fruit = ['apple','banana','strawberry','pineapple']
#fruit.add("mango")

fruit.append("mango")

3.
fruit = ['apple','banana','strawberry','pineapple']
fruit_string = ','.join(fruit)
#fruit = fruit_string.split()
fruit = fruit_string.split(',')
print(fruit[1])

4.
#fruit1 = fruit2 = ['apple','banana','strawberry','pineapple']
fruit1 = ['apple','banana','strawberry','pineapple']
fruit2 = fruit1.copy()

fruit2.remove('apple')
print(fruit1[3])

5.
def count_items_in_list(a_list):
    count = 0
    for item in a_list:
        count += 1
    return count
fruit = ['apple','banana','strawberry','pineapple']
#count_items_in_list(a_list)
count = count_items_in_list(a_list)
print(count)

6.
number = 5
if number < 10:
    print(number,'is lower than 10')

7.
numbers = {1:'one',2:'two',3:'three'}
#print(numbers['1'])
print(numbers[1])

8.
#number = 5413
number = [5,4,1,3]
if 1 in number:
    print("1 in", number)

27.
# что значит вызвать модуль в качестве сценария
#Вызвать модуль в качестве сценария Python означает запустить код, содержащийся в модуле, напрямую, как если бы он был основным сценарием. Это полезно, когда вы хотите использовать функции и переменные, определенные в модуле, без необходимости создавать новый файл сценария.
#Чтобы вызвать модуль в качестве сценария, вам нужно открыть командную строку или терминал и ввести команду “python”, за которой следует имя файла модуля. Например, если ваш модуль называется “mymodule.py”, вы должны ввести следующую команду:
#python mymodule.py
#Это запустит код в вашем модуле и позволит вам использовать его функции и переменные.

28.
# Что значит вызвать модуль с параметром python mymod.py 50
# Это значит, что вы хотите вызвать (запустить) модуль с аргументом (параметром) 50.
# Параметр - это дополнительная информация, которую вы передаете программе при ее запуске. В данном случае, вы передаете число 50 в модуль mymod.py. Это число будет доступно в коде модуля как часть команды sys.argv. Команда sys.argv содержит список всех аргументов, переданных программе при ее запуске.

# Если в вашем модуле есть следующий код:

import sys

print(sys.argv)
# То при запуске этого модуля с параметром 50, вы увидите вывод:

# ['python', 'mymod.py', '50']
# В этом случае, ‘50’ - это ваш параметр, который был передан в программу.

29.
#Когда интерпретатор python запускается с флагом -O
# Интерпретатор Python запускается с флагом -O для оптимизации кода. Это включает в себя несколько оптимизаций, таких как удаление неиспользуемого кода, упрощение выражений и удаление отступов. Это может помочь ускорить выполнение кода, но может также привести к изменению его поведения, если код зависит от этих неиспользуемых или удаленных элементов.

30.
# Когда байт-код не будет записан в файл .рус или .руо
#Байт-код не будет записываться в файл с расширением .pyc или .pyo, если Python не был скомпилирован с опцией включения байт-кода. В этом случае Python будет создавать и использовать только исходный код Python.
31.
# какова функция модуля __init__.py в пакете

#Модуль __init__.py служит двум целям в пакете:

#– Он говорит Python, что данный каталог является пакетом. Если такой файл присутствует в каталоге, Python рассматривает все .py-файлы в этом каталоге как модули и пытается импортировать их.
#– Он может содержать код для инициализации пакета. Например, он может импортировать и инициализировать другие модули в пакете или устанавливать переменные окружения для пакета.

32.
# Что означает from пакет import *
#Это означает, что вы импортируете все имена из указанного пакета в текущий контекст. Например, если у вас есть пакет с именем my_package, и в этом пакете есть функция с именем say_hello, то после выполнения from my_package import *, вы сможете использовать функцию say_hello в текущем контексте, не указывая полный путь (например, my_package.say_hello()).

33.
# файл __init__py в пакете содержит __all__ = ['echo','surround','reverse'] что это

#Файл __init__.py в пакете содержит специальную переменную __all__. Она указывает, какие элементы данного пакета (модули, функции, классы и т.д.) будут “экспортироваться” из пакета, то есть будут доступны для использования вне данного пакета. В данном примере, элементы с именами echo, surround и reverse станут доступны для использования вне пакета.

34.
# Что делают if __name__ == "__main__"

#Это условие выполняется, когда файл запускается как основная программа, а не когда он импортируется другим модулем. Оно позволяет выполнять код только в том случае, если файл был запущен напрямую, а не импортирован.

35.
#Что вернет hash(1.0) == hash(1)
print(hash(1.0) == hash(1))

36.
#Что вернет [] == [] (true)? A [] is [] (false)
#Оператор «==» сравнивает значения объектов:
#Однако оператор «is» проверяет идентичность объектов:
#Он возвращает True, если оба объекта указывают на одно и то же место в памяти, и False в противном случае. 

print([] is [])

37.
#Будут ли одинаковы id(a) id(b) при >>> a,b = 257,257
a,b = 257,257
print(a >> b)

38.
#Будут ли одинаковы id(a) id(b) при >>> a = 257 >>> b = 257

39.
#Будут ли одинаковы id(a) id(b) при >>> a = 255 >>> b = 255

40.
#что вернет >>> 1 > (0 < 1) что вернет >>> 1 == (0 < 1)

41.
#Что вернет True + 1 = 2
print(True + 1) 

42.
print(type([1]))
print(type([1].append(2)))

43.
a = float('inf')
print(a)

44.
#Сколько булевых значений в [False,1.0,"some_string",3,True,[],False] а сколько типа int
#булевых = 4
#int = 2
print([False,1.0,"some_string",3,True,[],False])

#Что будет напкчатано
45.
t = ('one','two')
for i in t:
    print(i)

46.
t = ('one')
for i in t:
    print(t)

47.
t = ()
print(t)

48.
#В следующем коде
class MyClass:
    pass

a = MyClass()
#Будут ли равны
print(MyClass.__hash__(a) == a.__hash__() == hash(a))

49.
#Что верент list(map(str.upper,['a','d'])) a map(str.upper,['a','d']
#map() перебирает элементы итерируемого массива (или коллекции) и возвращает новый массив (или итерируемый объект), который является результатом применения функции преобразования к каждому элементу исходного итерабельного массива
print(list(map(str.upper,['a','d'])))
list2 = map(str.upper,['a','d'])
print(list2)

50.
# Какую роль исполняет __slots__
#В Python, ключевое слово “slots” используется для определения атрибутов класса, которые могут быть инициализированы только один раз при создании экземпляра класса. Это позволяет экономить память, так как дублирование этих атрибутов не требуется.
class Example:
    __slots__ = ['attr1', 'attr2']

    def __init__(self, attr1, attr2):
        self.attr1 = attr1
        self.attr2 = attr2

ex = Example('Hello', 'World')
print(ex.attr1)  # Output: 'Hello'
print(ex.attr2)  # Output: 'World'

51.
# что такое @classmethod
#classmethod в Python используется при определении методов класса. Он позволяет создать метод, который будет работать с классом, а не с его экземплярами. Такой метод может быть вызван без создания экземпляра класса, что может быть полезно для создания фабричных функций или методов для манипуляции с классом.

52.
# что такое @staticmethod
#Статический метод - это метод, который работает с данными напрямую, без использования экземпляра класса. Такие методы не имеют доступа к закрытым членам класса и не могут изменять его состояние. Статические методы могут быть вызваны без создания экземпляра класса.
#Статические методы обычно используются для выполнения операций, которые не зависят от состояния экземпляра класса, например, для генерации случайных чисел или для конвертации единиц измерения.

53.
# Рассмотрим следующий код
class TestClass(object):
    @classmethod
    def f1(cls):
        print(cls.__name__)

class TestClass2(TestClass):
    pass

#Что будет напечатано
TestClass.f1()
TestClass2.f1()

a = TestClass2()
a.f1()

54.
#Рассмотрим следующий код
class My:
    num = 0
    def __init__(self):
        My.num = My.num + 1
    
    @staticmethod
    def showNum():
        print(My.num)
a = My()
b = My()
My().showNum()

b.showNum()

55.
# Как устроены абстрактные классы в Python
#Abstract Base Classes (ABCs) в Python — это базовые классы, которые могут быть использованы для определения интерфейсов для других классов. Они позволяют определить набор методов и свойств, которые должны быть реализованы в подклассах.
#Чтобы определить абстрактную базовую класс, необходимо использовать ключевое слово abc.ABCMeta и метод register. Например:
from abc import ABCMeta, abstractmethod

class AbstractClass(metaclass=ABCMeta):
    @abstractmethod
    def abstract_method(self):
        pass

class ConcreteClass(AbstractClass):
    def abstract_method(self):
        return "Concrete method"
    
#Как организована сериализация и десериализация в Python
#В Python сериализация объектов выполняется с помощью модуля pickle. Этот модуль позволяет сохранять объекты в виде последовательности байтов, которые могут быть сохранены в файл или переданы по сети.
#Десериализация выполняется с помощью функции loads из модуля pickle. Эта функция принимает байтовый объект, который был создан функцией dumps и возвращает десериализованный объект.
#Следует отметить, что использование модуля pickle может представлять угрозу безопасности, так как он позволяет сохранять и загружать объекты произвольного типа, что может привести к выполнению вредоносного кода. Для решения этой проблемы следует использовать сериализацию и десериализацию только для доверенных данных.
    
import pickle

# Создаем объект, который нужно сериализовать
obj = {
    'name': 'Alice',
    'age': 25,
    'skills': ['Python', 'Django', 'Linux']
}

# Сериализуем объект в байтовый объект
with open('data.pickle', 'wb') as file:
    pickle.dump(obj, file)

# Десериализуем байтовый объект обратно в объект
with open('data.pickle', 'rb') as file:
    deserialized_obj = pickle.load(file)

print(deserialized_obj['name'])  # Вывод: Alice
print(deserialized_obj['age'])  # Вывод: 25
print(deserialized_obj['skills'])  # Вывод: ['Python', 'Django', 'Linux']

56.
# Назовите неизменяемые типы Python

#Некоторые неизменяемые типы данных в Python включают:

#– Числа (целочисленные, вещественные, комплексные)
#– Строки
#– Кортежи
#– Списки кортежей
#– Множество (неизменяемо по определению)
#– Байтовые строки
#– Словари, где значения также являются неизменяемыми типами
#– Некоторые структуры данных, такие как frozenset и types.MappingProxyType

#Обратите внимание, что некоторые другие структуры данных, такие как списки и словари, могут содержать неизменяемые значения, но сами по себе являются изменяемыми.

57.
# Назовите изменяемые типы Python
#Некоторые изменяемые типы данных в Python включают:

#– Списки (списки изменяемы по определению)
#– Словари (словари изменяемы по определению, так как они являются ассоциативными массивами)
#– Множества (множества изменяемы, если они содержат кортежи)
#– Генераторы
#– Итераторы
#– Некоторые пользовательские структуры данных, такие как классы и объекты.

58.
#как задать неизменяемые типы в python

#В Python нет возможности сделать тип данных полностью неизменяемым, но можно создать классы и структуры данных, которые будут вести себя как неизменяемые. Например, можно использовать кортежи для создания неизменяемых объектов:

#a = ('Hello',)  # Создаем кортеж
#b = a  # Копируем кортеж в другую переменную
#b[0] = 'Goodbye'  # Попытка изменить значение кортежа приведет к ошибке
#В этом примере переменная a содержит кортеж с одним элементом - строкой “Hello”. Мы копируем этот кортеж в переменную b и пытаемся изменить значение в кортеже, но получаем ошибку, потому что кортежи являются неизменяемыми.

59.
#Что делает следующий код MyType = type('MyType',(object),{'a:1'})
#Основополагающий тип. Конструктор для динамических пользовательских типов.
#Один аргумент:
#obj : Объект, тип которого требуется определить.
#Три аргумента:
#name : Имя для создаваемого типа (становится атрибутом __name__);
#bases : Кортеж с родительскими классами (становится атрибутом __bases__);
#dict : Словарь, который будет являться пространством имён для тела класса (становится атрибутом __dict__).

# Определение типа при помощи инструкции class
class MyType:  # Для Python 2 — MyType(object)
    a = 1

# То же определение типа, но во время исполнения при помощи type()
MyType = type('MyType', (object,), {'a': 1})
print(MyType)

60.
#Какие типы можно использовать в качестве ключей в словарях
#В Python в качестве ключей словаря могут использоваться любые неизменяемые типы, включая числа, строки, кортежи, байтовые строки и т.д. Однако, в большинстве случаев рекомендуется использовать уникальные, immutable и hashable объекты, такие как строки, числа и кортежи.
#Использование изменяемых типов, таких как списки или словари, в качестве ключей может привести к нежелательным последствиям, таким как неожиданные изменения в словаре или ошибки во время выполнения программы.

61.
#Что означает переопределить метод hash
#Переопределение метода hash в классе означает, что этот класс может использоваться в качестве ключа словаря. Если класс переопределяет метод __hash__, то при использовании объектов этого класса в качестве ключей словаря будет вызываться этот метод для вычисления хэша объекта.
#Переопределение метода __hash__ должно следовать некоторым правилам, чтобы обеспечить корректную работу словаря. Во-первых, этот метод должен всегда возвращать одно и то же значение для одного и того же объекта, чтобы гарантировать уникальность ключей. Во-вторых, значения, возвращаемые методом __hash__(), должны быть равномерно распределены, чтобы избежать коллизий ключей, которые могут привести к снижению производительности словаря.

62.
#Что произойдет при выполнении кода
d= dict([("a",1),("a",21)])
print(d)
